using System;using System.Reflection;using System.Reflection.Emit;using Boa.Runtime;// TODO: implement documentation stringsnamespace Boa.AST{public sealed class BoaFunction : Node{ public BoaFunction(Node from, Parameter[] parms, Statement body)  { Parameters=parms; Body=body; SetLocation(from.Source, from.Line, from.Column);  }  public BoaFunction(Node from, string name, Parameter[] parms, Statement body) : this(from, parms, body)  { Name=new Name(name);  }  public Name   Name;  public Name[] Inherit, Globals;  public Parameter[] Parameters;  public Statement Body;  public string FuncName { get { return Name==null ? "lambda" : Name.String; } }  public void Emit(CodeGenerator cg)  { CodeGenerator impl = MakeImplMethod(cg);

    Type targetType = Inherit==null ? typeof(CallTargetN) : typeof(CallTargetFN);
    Type funcType   = Inherit==null ? typeof(CompiledFunctionN) : typeof(CompiledFunctionFN);
    
    cg.EmitString(Name==null ? null : Name.String);
    EmitClosedGet(cg);
    cg.ILG.Emit(OpCodes.Ldnull); // create delegate
    cg.ILG.Emit(OpCodes.Ldftn, impl.MethodBuilder);
    cg.EmitNew((ConstructorInfo)targetType.GetMember(".ctor")[0]);
    cg.EmitNew(funcType, new Type[] { typeof(string), typeof(ClosedVar[]), targetType });
  }  public object MakeFunction(Frame frame)  { if(names==null) Initialize();    object[] defaults = numOptional==0 ? null : new object[numOptional];    for(int i=0; i<numOptional; i++) defaults[i] = Parameters[i+optionalStart].Default.Evaluate(frame);    return new InterpretedFunction(Name.String, names, defaults, hasList, hasDict, numRequired, Globals, frame, Body);  }    public override void ToCode(System.Text.StringBuilder sb, int indent) { throw new NotSupportedException(); }
  public override void Walk(IWalker w)  { if(w.Walk(this)) Body.Walk(w);    w.PostWalk(this);  }  void EmitClosedGet(CodeGenerator cg)  { if(Inherit==null) cg.ILG.Emit(OpCodes.Ldnull);    else    { cg.EmitNewArray(typeof(ClosedVar), Inherit.Length);      ConstructorInfo ci = typeof(ClosedVar).GetConstructor(new Type[] { typeof(string) });      FieldInfo fi = typeof(ClosedVar).GetField("Value");      for(int i=0; i<Inherit.Length; i++)      { cg.ILG.Emit(OpCodes.Dup);        cg.EmitInt(i);        Slot slot = cg.Namespace.GetLocalSlot(Inherit[i]);        ClosedSlot cs = slot as ClosedSlot;        if(cs!=null) cs.Storage.EmitGet(cg);        else        { cg.EmitString(Inherit[i].String);          cg.EmitNew(ci);          cg.ILG.Emit(OpCodes.Dup);          slot.EmitGet(cg);          cg.EmitFieldSet(fi);        }        cg.ILG.Emit(OpCodes.Stelem_Ref);      }    }  }  void Initialize()  { bool os = false;    names = new string[Parameters.Length];    for(int i=0; i<Parameters.Length; i++)    { names[i] = Parameters[i].Name.String;      switch(Parameters[i].Type)      { case ParamType.Required: numRequired++; break;        case ParamType.Optional:          if(os) numOptional++;          else { optionalStart=i; numOptional=1; os=true; }          break;        case ParamType.List: hasList=true; break;        case ParamType.Dict: hasDict=true; break;      }    }  }  CodeGenerator MakeImplMethod(CodeGenerator cg)  { Name[] names = new Name[Parameters.Length];     for(int i=0; i<Parameters.Length; i++) names[i] = Parameters[i].Name;    Type[] parmTypes = Inherit==null ? new Type[] { typeof(object[]) }                                     : new Type[] { typeof(CompiledFunction), typeof(object[]) };    CodeGenerator icg = cg.TypeGenerator.DefineMethod(FuncName + "$f" + index++, typeof(object), parmTypes);    LocalNamespace ns = new LocalNamespace(cg.Namespace, icg);    icg.Namespace = ns;    //icg.SetArgs(names, 1);    ns.SetArgs(names, icg, new ArgSlot(icg.MethodBuilder, Inherit==null ? 0 : 1, "$names", typeof(object[])));    if(Inherit!=null && Inherit.Length>0)    { icg.EmitArgGet(0);      icg.EmitFieldGet(typeof(CompiledFunction), "Closed");      for(int i=0; i<Inherit.Length; i++)      { if(i!=Inherit.Length-1) icg.ILG.Emit(OpCodes.Dup);        icg.EmitInt(i);        icg.ILG.Emit(OpCodes.Ldelem_Ref);        ns.UnpackClosedVar(Inherit[i], icg);      }    }    Body.Emit(icg);    icg.EmitReturn(null);    icg.Finish();    return icg;  }  Slot namesSlot;  string[] names;  int optionalStart, numOptional, numRequired;  bool hasList, hasDict;  static int index;}} // namespace Boa.AST